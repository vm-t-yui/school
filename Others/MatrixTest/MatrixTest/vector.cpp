//--------------------------------//
//	ベクトルライブラリ			  //
//						2008/1/9  //
//						由比　建　//
//--------------------------------//
//-----------------------------------------------------------------------------
// Copyright (c) 2016 Takeru Yui.
//-----------------------------------------------------------------------------

//ヘッダのインクルード
#include "Vector.h"

//--------------------------------//
//	引数つきコンストラクタ
//	引数	：初期化する要素
//	役割	：ベクトルをそれぞれの引数で初期化する
//--------------------------------//
Vector3::Vector3(float aug_x, float aug_y, float aug_z)
{
    x = aug_x;
    y = aug_y;
    z = aug_z;
}

//--------------------------------//
//	引数つきコンストラクタ
//	引数	：初期化する要素
//	役割	：ベクトルを一つ引数で初期化する
//--------------------------------//
Vector3::Vector3(float v)
{
    x = v;
    y = v;
    z = v;
}


//--------------------------------//
//	関数名	：Set
//	引数	：セットする値
//	戻り値	：なし
//	役割	：渡された値をセットする
//--------------------------------//
void Vector3::Set(float aug_x, float aug_y, float aug_z)
{
    x = aug_x;	y = aug_y; z = aug_z;
}


//--------------------------------//
//	関数名	：Length
//	引数	：なし
//	戻り値	：求めた長さ
//	役割	：自分自身のベクトルの長さを求めて返す
//--------------------------------//
float Vector3::Length()
{
    return ((float)sqrt((x * x) + (y * y) + (z * z)));
}


//--------------------------------//
//	関数名	：Normalize
//	引数	：なし
//	戻り値	：正規化したベクトル
//	役割	：自分自身を正規化したものを返す
//--------------------------------//
Vector3 Vector3::Normalize()
{
    if (Length())
        return Vector3(x / Length(), y / Length(), z / Length());
    return Vector3(0, 0, 0);
}


///--------------------------------//
///	関数名	：Proj
////	引数	：投影するベクトル
///	戻り値	：自分自身を投影したベクトル
///	役割	：引数のベクトルに自分自身を投影したベクトルを返す
///--------------------------------//
//Vector3 Vector3::Proj(Vector3 &a)								
//{
//	return Vector3(0,0,0);
//
//}
//
//
///--------------------------------//
///	関数名	：Perp
////	引数	：Perpするベクトル
///	戻り値	：自分自身をPerpしたベクトル
///	役割	：引数のベクトルに自分自身をPerpしたベクトルを返す
///--------------------------------//
//Vector3 Vector3::Perp(Vector3 &a)							
//{
//	return Vector3(0,0,0);
//
//}

//--------------------------------//
//	関数名	：Print
//	引数	：なし
//	戻り値	：なし
//	役割	：自分自身をコンソールに表示する
//--------------------------------//
void Vector3::Print()
{
    printf("x:%f y:%f z:%f\n", x, y, z);
}



//----------------------------------------------------------------------------------------------//
//ここから演算子の	オーバーロード
//----------------------------------------------------------------------------------------------//

//--------------------------------//
//	オーバーロードした演算子：=
//	引数	：代入するベクトルと代入されるベクトル
//	戻り値	：引数
//	役割	：引数のベクトルを自分に代入する
//--------------------------------//
Vector3 &Vector3::operator = (const Vector3 &a)
{
    x = a.x;
    y = a.y;
    z = a.z;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：==
//	引数	：比較するベクトル二つ
//	戻り値	：ほぼ同じかどうか
//	役割	：二つのベクトルをほぼ同じかどうか調べて返す
//--------------------------------//
bool operator == (Vector3 &a, Vector3 &b)
{
    Vector3 ans = a - b;
    if (ans.x < 0.0001f && ans.x > -0.0001f &&
        ans.y < 0.0001f && ans.y > -0.0001f &&
        ans.z < 0.0001f && ans.z > -0.0001f)
        return true;
    else
        return false;
}

//--------------------------------//
//	オーバーロードした演算子：+
//	引数	：足し算するベクトル二つ
//	戻り値	：足した結果
//	役割	：ベクトルどうしを足し算して返す
//--------------------------------//
Vector3 operator + (Vector3 &a, Vector3 &b)
{
    return Vector3(a.x + b.x, a.y + b.y, a.z + b.z);
}
//--------------------------------//
//	オーバーロードした演算子：+=
//	引数	：足し算するベクトル
//	戻り値	：足した結果の自分
//	役割	：引数を自分に足す
//--------------------------------//
Vector3 &Vector3::operator += (const Vector3 &a)
{
    x += a.x;
    y += a.y;
    z += a.z;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：-
//	引数	：引き算するベクトル二つ
//	戻り値	：引いた結果
//	役割	：ベクトルどうしを引き算して返す
//--------------------------------//
Vector3 operator - (Vector3 &a, Vector3 &b)
{
    return Vector3(a.x - b.x, a.y - b.y, a.z - b.z);
}
//--------------------------------//
//	オーバーロードした演算子：-=
//	引数	：引き算するベクトル
//	戻り値	：引いた結果の自分
//	役割	：引数を自分に引く
//--------------------------------//
Vector3 &Vector3::operator -= (const Vector3 &a)
{
    x -= a.x;
    y -= a.y;
    z -= a.z;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：*
//	引数	：内積を計算するベクトル二つ
//	戻り値	：計算した結果のスカラー
//	役割	：二つのベクトルの内積を返す
//--------------------------------//
float operator * (Vector3 &a, Vector3 &b)
{
    return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z));
}


//--------------------------------//
//	オーバーロードした演算子：*
//	引数	：スカラー倍するベクトルと任意の数
//	戻り値	：スカラー倍したベクトル
//	役割	：ベクトルを引数分スカラー倍して返す
//--------------------------------//
Vector3 operator * (Vector3 &a, float n)
{
    return Vector3(a.x * n, a.y * n, a.z * n);
}
Vector3 operator * (float n, Vector3 &a)
{
    return Vector3(a.x * n, a.y * n, a.z * n);
}
//--------------------------------//
//	オーバーロードした演算子：*=
//	引数	：かけ算するスカラー
//	戻り値	：かけた結果の自分
//	役割	：引数を自分にかける
//--------------------------------//
Vector3 &Vector3::operator *= (const float n)
{
    x *= n;
    y *= n;
    z *= n;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：/
//	引数	：スカラー除算するベクトルと任意の数
//	戻り値	：スカラー除算したベクトル
//	役割	：ベクトルを引数分スカラー除算して返す
//--------------------------------//
Vector3 operator / (Vector3 &a, float n)
{
    if (n != 0)
        return Vector3(a.x / n, a.y / n, a.z / n);
    else
    {
        return Vector3(0, 0, 0);
        puts("ベクトルクラス内でゼロ除算発生");
    }
}
Vector3 operator / (float n, Vector3 &a)
{
    if (n != 0)
        return Vector3(a.x / n, a.y / n, a.z / n);
    else
    {
        return Vector3(0, 0, 0);
        puts("ベクトルクラス内でゼロ除算発生");
    }
}
//--------------------------------//
//	オーバーロードした演算子：/=
//	引数	：除算するスカラー
//	戻り値	：除算した結果の自分
//	役割	：引数で自分を除算する
//--------------------------------//
Vector3 &Vector3::operator /= (const float n)
{
    if (n != 0)
    {
        x /= n;
        y /= n;
        z /= n;
        return *this;
    }
    else
    {
        (*this) = Vector3(0, 0, 0);
        return *this;
        puts("ベクトルクラス内でゼロ除算発生");
    }
}

//--------------------------------//
//	オーバーロードした演算子：%
//	引数	：外積を求めるベクトル二つ
//	戻り値	：計算したベクトル
//	役割	：二つのベクトルの外積を計算して返す
//--------------------------------//
Vector3 operator % (Vector3& a, Vector3& b)
{
    return Vector3((a.y*b.z - a.z*b.y), (a.z*b.x - a.x*b.z), (a.x*b.y - a.y*b.x));

}
//--------------------------------//
//	オーバーロードした演算子：%=
//	引数	：外積を計算するベクトル
//	戻り値	：計算した結果の自分
//	役割	：外積の結果を自分に代入する
//--------------------------------//
Vector3 &Vector3::operator %= (const Vector3 &a)
{
    Vector3 temp;
    temp.x = ((y * a.z) - (z * a.y));
    temp.y = ((z * a.x) - (x * a.z));
    temp.z = ((x * a.y) - (y * a.x));

    x = temp.x;
    y = temp.y;
    z = temp.z;

    return *this;
}


///--------------------------------//
////	オーバーロードした演算子：||
////	引数	：調べるベクトル
///	戻り値	：true:  平行である
///　　　　false: 平行でない
///	役割	：引数のベクトルが自分と平行でないか調べる
///--------------------------------//
//bool operator || (Vector3& a,Vector3& b)	
//{
//	return 0;
//
//}


//----------------------------------------------------------------------------------------------------//
// Vector4
//----------------------------------------------------------------------------------------------------//

//--------------------------------//
//	オーバーロードした演算子：+
//	引数	：足し算するベクトル二つ
//	戻り値	：足した結果
//	役割	：ベクトルどうしを足し算して返す
//--------------------------------//
Vector4 operator + (Vector4 &a, Vector4 &b)
{
    return Vector4(a.x + b.x, a.y + b.y, a.z + b.z, a.w + b.w);
}
//--------------------------------//
//	オーバーロードした演算子：+=
//	引数	：足し算するベクトル
//	戻り値	：足した結果の自分
//	役割	：引数を自分に足す
//--------------------------------//
Vector4 &Vector4::operator += (const Vector4 &a)
{
    x += a.x;
    y += a.y;
    z += a.z;
    w += a.w;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：-
//	引数	：引き算するベクトル二つ
//	戻り値	：引いた結果
//	役割	：ベクトルどうしを引き算して返す
//--------------------------------//
Vector4 operator - (Vector4 &a, Vector4 &b)
{
    return Vector4(a.x - b.x, a.y - b.y, a.z - b.z, a.w - b.w);
}
//--------------------------------//
//	オーバーロードした演算子：-=
//	引数	：引き算するベクトル
//	戻り値	：引いた結果の自分
//	役割	：引数を自分に引く
//--------------------------------//
Vector4 &Vector4::operator -= (const Vector4 &a)
{
    x -= a.x;
    y -= a.y;
    z -= a.z;
    w -= a.w;
    return *this;
}


//--------------------------------//
//	オーバーロードした演算子：*
//	引数	：内積を計算するベクトル二つ
//	戻り値	：計算した結果のスカラー
//	役割	：二つのベクトルの内積を返す
//--------------------------------//
float operator * (Vector4 &a, Vector4 &b)
{
    return ((a.x * b.x) + (a.y * b.y) + (a.z * b.z) + (a.w * b.w));
}


//--------------------------------//
//	オーバーロードした演算子：*
//	引数	：スカラー倍するベクトルと任意の数
//	戻り値	：スカラー倍したベクトル
//	役割	：ベクトルを引数分スカラー倍して返す
//--------------------------------//
Vector4 operator * (Vector4 &a, float n)
{
    return Vector4(a.x * n, a.y * n, a.z * n, a.w * n);
}
Vector4 operator * (float n, Vector4 &a)
{
    return Vector4(a.x * n, a.y * n, a.z * n, a.w * n);
}
//--------------------------------//
//	オーバーロードした演算子：*=
//	引数	：かけ算するスカラー
//	戻り値	：かけた結果の自分
//	役割	：引数を自分にかける
//--------------------------------//
Vector4 &Vector4::operator *= (const float n)
{
    x *= n;
    y *= n;
    z *= n;
    w *= n;
    return *this;
}
//--------------------------------//
//	オーバーロードした演算子：/
//	引数	：スカラー除算するベクトルと任意の数
//	戻り値	：スカラー除算したベクトル
//	役割	：ベクトルを引数分スカラー除算して返す
//--------------------------------//
Vector4 operator / (Vector4 &a, float n)
{
    if (n != 0)
        return Vector4(a.x / n, a.y / n, a.z / n, a.w / n);
    else
    {
        return Vector4(0, 0, 0, 0);
        puts("ベクトルクラス内でゼロ除算発生");
    }
}
Vector4 operator / (float n, Vector4 &a)
{
    if (n != 0)
        return Vector4(a.x / n, a.y / n, a.z / n, a.w / n);
    else
    {
        return Vector4(0, 0, 0, 0);
        puts("ベクトルクラス内でゼロ除算発生");
    }
}


//----------------------------------------------------------------------------------------------------//
// 関数
//----------------------------------------------------------------------------------------------------//
//--------------------------------//
//	二つのベクトルの成す角を返す
//	引数	：ベクトル二つ
//	戻り値	：なす角（ラジアン）
//--------------------------------//
float GetTwoVecRad(Vector3& a, Vector3& b)
{
    return(acosf(a*b / (a.Length() * b.Length())));
}